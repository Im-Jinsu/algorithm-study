# 백준 동적프로그래밍(DP) 문제
- 정수 삼각형(1932)
    - https://www.acmicpc.net/problem/1932

## 풀이 방법
### 문제와 주어진 조건 이해하기

### 문제 접근 방법
- 현재 노드에서 아래로 내려갈때 최대값을 선택하는것은 좋은 방법이 아니다. 
- 아래로 내려갈때 '어떤 노드를 선택해야 하나'는 두개의 노드중에 어떤 노드가 아래에서부터 올라와 더 큰 값을 갖고있냐 를 판단해 선택하려 했다.
- 그러려면 각 노드가 자신과 총합 두 가지 정보를 갖고있어야 하므로 class 생성을 고려했다.
- 그리고 아래로 내려갈 때 두 노드를 선택할때마다 두 노드의 경로를 알아야 하므로 재귀함수를 구현하려 했다.
- 순간 풀이방식이 복잡해지고 있으며 비효율적 방안임을 느꼈다.

### 해결하지 못한 이유
- 구현스킬 부족: 재귀함수 구현 미숙. 
- 문제해결능력 부족: 재귀나 클래스를 안쓰더라도 지금까지의 총합을 나타낼 수 있는 방법을 생각하지 못했다. **현재노드가 다음노드를 선택** 하는게 초점이 아닌, **현재 노드가 위의 노드 중 선택, 그것이 곧 지금까지의 경로를 선택** 하는게 초점이다.
- greedy 문제에 해당된다. **현재노드는 최대값 경로를 선택한다** 가 결국 반복적으로 일어나 최종에서는 최대값 경로를 알 수 있기 때문이다.

### 문제를 해결한 방법
- 재귀함수, 클래스를 쓰지 않아도 모든 노드들이 지금까지 이동한 값을 알 수 있다.
    - 동적 프로그래밍(DP)의 **메모제이션**
- 모든 노드를 방문한다. 
- 현재 노드는 자신의 값과 왼쪽 or 오른쪽 윗노드의 값을 합친 값을 갖게된다.
    - 이때 왼쪽윗노드, 오른쪽윗노드 중에 더 큰 값을 선택하게 된다. 
- 맨 왼쪽, 맨 오른쪽 노드들은 한 방향에서 밖에 못오니까 조건문으로 따로 처리한다. 
- 갑자기 최대값 경로 노드가 바뀌어도 바뀐 노드가 지금까지의 총합을 알고 있기 때문에 유연하다. 
    - 다시 계산하지 않아도 되는 **메모제이션 기법** 덕분이다.
- 최대값을 찾는 방법은, 현재 노드 방문시 그 노드는 위에서 올라온 값+자신의 값을 가지므로 sum과 비교해 자신의 값이 크면 sum이 된다. 
- 모든노드 방문 시 가장 큰 sum은 가장 아래단 노드에서 나올 것이며 그 노드가 위부터 내려온 값의 총합인 셈이다.
- 만약 경로를 구하라고 했다면 최종 노드부터 backtracking 하면 구할 수 있지않을까 싶다.

### 문제를 해결한 코드
```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int step[][] = new int[n+1][n+1];
        
        int sum=0;
        for(int i=1 ; i<=n ; i++){
            for(int j=1 ; j<=i ; j++){
                step[i][j] = sc.nextInt();
                
                if(j==1)
                    step[i][j] = step[i-1][j]+step[i][j];
                else if(i==j)
                    step[i][j] = step[i-1][j-1] + step[i][j];
                else
                    step[i][j] = Math.max(step[i-1][j-1],step[i-1][j])+step[i][j];
                if(sum< step[i][j])
                    sum = step[i][j];
            }
        }
        System.out.println(sum);
    }
}
```

### 구현 배경 지식
- 해당 노드에서 이동을 **하나의 일** 이라고 생각할때 이 문제는 작은 일이 반복적으로 일어나는 문제이다. 최대값 경로를 구해야 하고 노드를 방문할때마다 가장 큰 값이 위에서 내려온다. 정리하자면 같은 문제를 구할때 마다 정답이 같다.
- 문제를 계속 진행하면서 앞서 풀었던 작은 문제의 값을 이용해야 한다. 
- 1.작은문제반복 2.같은문제는 매번 정답동일. 따라서 이 문제는 동적 프로그래밍(DP) 유형의 문제임을 알아야 한다. 




---
아래의 사이트를 참고해 작성된 글입니다.
- https://galid1.tistory.com/507
- https://nackwon.tistory.com/66