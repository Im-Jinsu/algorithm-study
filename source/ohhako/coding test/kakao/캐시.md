## 캐시
### 풀이 방법
#### 문제 주어진 조건 이해하기
- LRU는 가장 오래된 블럭을 교체하는 알고리즘인데 가장 오래된 블럭은 무엇이며 블럭을 어떻게 교체 하라는걸까
- cache hit/cache miss 가 무엇이며 param으로 들어온 캐시크기, 도시이름 배열과 무슨 상관이 있나
- 도시 배열 처리 시 실행시간을 어떻게 처리하나

카카오가 출제하는 문제의 특징은, 문제는 하나의 의도를 갖고 있지만 그 의도룰 해결하기 위해 수많은 이론, 코드 구현 방법을 알아야 한다는 것이다. 이 캐시 문제에 대한 출제자의 의도는 LRU를 구현하는 것이라고 한다. 이게 어떤 방식인지 이론은 알고 있지만 코드 구현 경험이 없다면 풀기 어렵다.
- [참고한 LRU 코드구현](https://doublesprogramming.tistory.com/254)
위의 코드를 보고 LRU의 동작 방식을 이해했다. <BR>
결국 이 문제를 종합적으로 다시 이해하자면 아래와 같다.
- 주어진 cache수 만큼 도시가 캐시에 존재할 수 있다.
- 배열을 순서대로 캐시에 저장할때 이미 있으면(hit) 실행시간 1, 없으면(miss) 실행시간 5가 걸린다.


#### 조건을 코드로 구현하기
```java
public static int cache(int cache,String[] cities) {
		int count=0;
		HashMap<String,Integer> hm = new LinkedHashMap<String,Integer>() {
			@Override
			protected boolean removeEldestEntry(Map.Entry<String,Integer> eld) {
				return size() > cache;
			}
			
		};
		
		for(int i=0 ; i<cache ; i++) {
			if(hm.containsKey(cities[i])) {
				hm.remove(cities[i]);
				hm.put(cities[0], 0);
				count++;
			}else {
				hm.put(cities[i],0);
				count+=5;
			}
		}
		
		for(int i=cache ; i<cities.length ; i++) {
			if(hm.containsKey(cities[i])) {
				hm.remove(cities[i]);
				hm.put(cities[i], 0);
				count++;
			}else {
				hm.put(cities[i],0);
				count+=5;
			}
		}
		
		return count;
	}

```




---
아래의 사이트를 참고해 작성된 글입니다.
- https://tech.kakao.com/2017/09/27/kakao-blind-recruitment-round-1/